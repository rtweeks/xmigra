module XMigra
  
  # Base class for XMigra plugins.
  #
  # Derive a class from this class, then call XMigra::Plugin.activate! with
  # a block that instantiates your class.
  #
  #   require "xmigra/plugin"
  #   
  #   class YearTemplatePlugin < XMigra::Plugin
  #     def amend_composed_sql(sql)
  #       sql.gsub! '[{year}]', Date.today.year.to_s
  #     end
  #   end
  #   
  #   XMigra::Plugin.activate! {YearTemplatePlugin.new}
  #
  # The last call to XMigra::Plugin.activate! will determine which block will
  # be executed to return the active plugin, so make sure to +require+ any
  # plugins to be aggregated before activating your own.
  
  class Plugin
    class LoadingError < ::LoadError; end
    
    class <<self
      attr_reader :active
      
      def loading?
        !!@load_depth
      end
      
      def load!(name)
        previous_depth, @load_depth = @load_depth, (@load_depth || 0) + 1
        @activation = nil if previous_depth.nil?
        begin
          require name
        rescue ::LoadError => error
          if previous_depth.nil? && error.path == name
            raise LoadingError, "The XMigra plugin #{name.inspect} is not installed (Kernel#require failed)."
          else
            raise
          end
        ensure
          @load_depth = previous_depth
        end
        
        if previous_depth.nil? && @activation
          @active = @activation.call
        end
      end
      
      def activate!(&blk)
        @activation = blk
      end
    end
    
    
    # Amend SQL coming from source documents.  The String object passed to
    # this method will be included in the commands to run, and any
    # modifications made to this object will be reflected in the script.
    # XMigra only calls this method to amend SQL read in from source files.
    #
    # The default implementation does nothing.
    
    def amend_source_sql(sql)
    end
    
    
    # Amend SQL for script after all parts are combined.  This method will
    # have an opportunity to amend all of the SQL in the output script,
    # including SQL generated by XMigra.
    #
    # XMigra only calls this method one time for the entire output script
    # _prior_ to any transformation necessary for script transactionality
    # (e.g. splitting the script into batches and encoding as string
    # literals).  The one exception to this is for any branch upgrade SQL,
    # which will already be encoded in one or more string literals.
    #
    # The default implementation does nothing.
    
    def amend_composed_sql(sql)
    end
    
    
    # Indicate if the access artifact (stored procedure, user defined function,
    # or view) should be included in the logical schema.
    #
    # The default implementation always returns +true+.
    
    def include_access_artifact?(artifact)
      true
    end
    
    
    # Amend each included access artifact.
    #
    # _artifact_ - an XMigra::StoredProcedure, XMigra::Function, or XMigra::View
    #
    # The default implementation does nothing.
    
    def amend_access_artifact(artifact)
    end
    
    
    # Yields additional access artifacts to include in the logical schema.
    #
    # _db_specifics_ - A module providing methods useful for building SQL
    #                  specific to the target RDBMS.
    # 
    # The yielded artifact objects must respond to +name+, +depends_on+ and
    # +definition_sql+.
    #
    # The default implementation does not yield any objects.
    
    def each_additional_access_artifact(db_specifics=nil) # :yields: artifact
    end
    
    
    # Indicate if the index should be included in the logical schema.
    #
    # The default implementation always return +true+.
    
    def include_index?(index)
      true
    end
    
    
    # Amend each included index.
    #
    # The default implementation does nothing.
    
    def amend_index(index)
    end
    
    
    # Yields additional indexes to include in the logical schema.
    #
    # _db_specifics_ - A module providing methods useful for building SQL
    #                  specific to the target RDBMS.
    # 
    # The yielded index objects must respond to +name+ and +definition_sql+.
    #
    # The default implementation does not yield any objects.
    
    def each_additional_index(db_specifics=nil) # :yields: index
    end
  end
end
